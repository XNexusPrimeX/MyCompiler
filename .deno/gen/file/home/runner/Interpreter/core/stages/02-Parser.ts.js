import { additiveOperators, allOperators, comparativeOperators, multiplicitateOperators, TokenType } from "@constants";
import { Statement } from "@structures";
import { AssignExpression, BinaryExpression, BooleanLiteral, Identifier, NumberLiteral, StringLiteral } from '@expressions';
import InterpreterError from "@errors";
export class Program extends Statement {
    kind = 'Program';
    body = [];
}
export class Parser {
    tokens = [];
    returns;
    at() {
        return this.tokens[0];
    }
    eat() {
        return this.tokens.shift();
    }
    isFileEnd() {
        return this.tokens[0].type === TokenType.EOF;
    }
    parse() {
        let primaryParse = () => {
            const tk = this.at().type;
            switch (tk) {
                case TokenType.Identifier: {
                    const symbol = this.eat().value;
                    if (this.at().value === '=') {
                        this.eat();
                        return new AssignExpression({
                            symbol,
                            value: this.parse()
                        });
                    }
                    return new Identifier({
                        symbol
                    });
                }
                case TokenType.Number: {
                    return new NumberLiteral({
                        value: parseFloat(this.eat().value)
                    });
                }
                case TokenType.String: {
                    return new StringLiteral({
                        value: this.eat().value
                    });
                }
                case TokenType.Boolean: {
                    return new BooleanLiteral({
                        value: this.eat().value === 'true' ? true : false
                    });
                }
                case TokenType.BinaryOperator: {
                    const binaryOp = this.eat();
                    if (!allOperators.includes(binaryOp.value)) {
                        throw new InterpreterError('UnexpectedCharacterError', binaryOp.value);
                    }
                    const nextToken = this.eat();
                    const isAdditiveOperation = additiveOperators.includes(binaryOp.value);
                    if (isAdditiveOperation && nextToken.type === TokenType.Number) {
                        return new NumberLiteral({
                            value: parseFloat(`${binaryOp.value}${nextToken.value}`)
                        });
                    }
                    else
                        throw new InterpreterError('SintaxError', 'number');
                }
                case TokenType.Paren: {
                    this.eat();
                    const value = this.parse();
                    this.eat();
                    return value;
                }
                default: throw new InterpreterError('SintaxError');
            }
        };
        let multiplicitaveParse = () => {
            let left = primaryParse();
            while (multiplicitateOperators.includes(this.at().value)) {
                const operator = this.eat().value;
                const right = primaryParse();
                left = new BinaryExpression({
                    left,
                    right,
                    operator,
                });
            }
            return left;
        };
        let additiveParse = () => {
            let left = multiplicitaveParse();
            while (additiveOperators.includes(this.at().value)) {
                const operator = this.eat().value;
                const right = multiplicitaveParse();
                left = new BinaryExpression({
                    left,
                    right,
                    operator,
                });
            }
            return left;
        };
        let comparativeParse = () => {
            let left = additiveParse();
            while (comparativeOperators.includes(this.at().value)) {
                const operator = this.eat().value;
                const right = additiveParse();
                left = new BinaryExpression({
                    left,
                    right,
                    operator
                });
            }
            return left;
        };
        return comparativeParse();
    }
    constructor(tokens) {
        this.tokens = tokens;
        const program = new Program();
        while (!this.isFileEnd()) {
            program.body.push(this.parse());
        }
        this.returns = program;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDItUGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiMDItUGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxZQUFZLEVBQUUsb0JBQW9CLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3ZILE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUM1SCxPQUFPLGdCQUFnQixNQUFNLFNBQVMsQ0FBQztBQUd2QyxNQUFNLE9BQU8sT0FBUSxTQUFRLFNBQVM7SUFDbEMsSUFBSSxHQUFHLFNBQWtCLENBQUM7SUFDMUIsSUFBSSxHQUFnQixFQUFFLENBQUM7Q0FDMUI7QUFFRCxNQUFNLE9BQU8sTUFBTTtJQUNQLE1BQU0sR0FBWSxFQUFFLENBQUM7SUFDdEIsT0FBTyxDQUFVO0lBRWhCLEVBQUU7UUFDTixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFVLENBQUM7SUFDbkMsQ0FBQztJQUNPLEdBQUc7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFXLENBQUM7SUFDeEMsQ0FBQztJQUNPLFNBQVM7UUFDYixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxHQUFHLENBQUM7SUFDakQsQ0FBQztJQUNPLEtBQUs7UUFDVCxJQUFJLFlBQVksR0FBRyxHQUFHLEVBQUU7WUFDcEIsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQztZQUUxQixRQUFRLEVBQUUsRUFBRTtnQkFDUixLQUFLLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztvQkFDdkIsTUFB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LENBQUM7SUFDOUIsQ0FBQztJQUVELFlBQVksTUFBNEI7UUFDcEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFFckIsTUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUU5QixPQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFO1lBQ3JCLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFBO1NBQ2xDO1FBRUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDM0IsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYWRkaXRpdmVPcGVyYXRvcnMsIGFsbE9wZXJhdG9ycywgY29tcGFyYXRpdmVPcGVyYXRvcnMsIG11bHRpcGxpY2l0YXRlT3BlcmF0b3JzLCBUb2tlblR5cGUgfSBmcm9tIFwiQGNvbnN0YW50c1wiO1xuaW1wb3J0IHsgU3RhdGVtZW50IH0gZnJvbSBcIkBzdHJ1Y3R1cmVzXCI7XG5pbXBvcnQgeyBBc3NpZ25FeHByZXNzaW9uLCBCaW5hcnlFeHByZXNzaW9uLCBCb29sZWFuTGl0ZXJhbCwgSWRlbnRpZmllciwgTnVtYmVyTGl0ZXJhbCwgU3RyaW5nTGl0ZXJhbCB9IGZyb20gJ0BleHByZXNzaW9ucyc7XG5pbXBvcnQgSW50ZXJwcmV0ZXJFcnJvciBmcm9tIFwiQGVycm9yc1wiO1xuaW1wb3J0IHsgVG9rZW4sIFRva2VuaXplciB9IGZyb20gXCIuLzAxLVRva2VuaXplci50c1wiO1xuXG5leHBvcnQgY2xhc3MgUHJvZ3JhbSBleHRlbmRzIFN0YXRlbWVudCB7XG4gICAga2luZCA9ICdQcm9ncmFtJyBhcyBjb25zdDtcbiAgICBib2R5OiBTdGF0ZW1lbnRbXSA9IFtdO1xufVxuXG5leHBvcnQgY2xhc3MgUGFyc2VyIHtcbiAgICBwcml2YXRlIHRva2VuczogVG9rZW5bXSA9IFtdO1xuICAgIHB1YmxpYyByZXR1cm5zOiBQcm9ncmFtO1xuXG4gICAgcHJpdmF0ZSBhdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zWzBdIGFzIFRva2VuO1xuICAgIH1cbiAgICBwcml2YXRlIGVhdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnNoaWZ0KCkgYXMgVG9rZW47XG4gICAgfVxuICAgIHByaXZhdGUgaXNGaWxlRW5kKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbMF0udHlwZSA9PT0gVG9rZW5UeXBlLkVPRjtcbiAgICB9XG4gICAgcHJpdmF0ZSBwYXJzZSgpOiBTdGF0ZW1lbnQge1xuICAgICAgICBsZXQgcHJpbWFyeVBhcnNlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGsgPSB0aGlzLmF0KCkudHlwZTtcblxuICAgICAgICAgICAgc3dpdGNoICh0aykge1xuICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLklkZW50aWZpZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gdGhpcy5lYXQoKS52YWx1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmF0KCkudmFsdWUgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBc3NpZ25FeHByZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMucGFyc2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElkZW50aWZpZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5OdW1iZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJMaXRlcmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHRoaXMuZWF0KCkudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5TdHJpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdMaXRlcmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmVhdCgpLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkJvb2xlYW46IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuTGl0ZXJhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5lYXQoKS52YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5CaW5hcnlPcGVyYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5hcnlPcCA9IHRoaXMuZWF0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIWFsbE9wZXJhdG9ycy5pbmNsdWRlcyhiaW5hcnlPcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcnByZXRlckVycm9yKCdVbmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3InLCBiaW5hcnlPcC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLmVhdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQWRkaXRpdmVPcGVyYXRpb24gPSBhZGRpdGl2ZU9wZXJhdG9ycy5pbmNsdWRlcyhiaW5hcnlPcC52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoaXNBZGRpdGl2ZU9wZXJhdGlvbiAmJiBuZXh0VG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJMaXRlcmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChgJHtiaW5hcnlPcC52YWx1ZX0ke25leHRUb2tlbi52YWx1ZX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEludGVycHJldGVyRXJyb3IoJ1NpbnRheEVycm9yJywgJ251bWJlcicpOyBcbiAgICAgICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuUGFyZW46IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXQoKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucGFyc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgSW50ZXJwcmV0ZXJFcnJvcignU2ludGF4RXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbXVsdGlwbGljaXRhdmVQYXJzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gcHJpbWFyeVBhcnNlKClcblxuICAgICAgICAgICAgd2hpbGUobXVsdGlwbGljaXRhdGVPcGVyYXRvcnMuaW5jbHVkZXModGhpcy5hdCgpLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5lYXQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHByaW1hcnlQYXJzZSgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgQmluYXJ5RXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZGl0aXZlUGFyc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IG11bHRpcGxpY2l0YXZlUGFyc2UoKVxuXG4gICAgICAgICAgICB3aGlsZShhZGRpdGl2ZU9wZXJhdG9ycy5pbmNsdWRlcyh0aGlzLmF0KCkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLmVhdCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbXVsdGlwbGljaXRhdmVQYXJzZSgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgQmluYXJ5RXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbXBhcmF0aXZlUGFyc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGFkZGl0aXZlUGFyc2UoKVxuICAgICAgICAgICAgd2hpbGUoY29tcGFyYXRpdmVPcGVyYXRvcnMuaW5jbHVkZXModGhpcy5hdCgpLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5lYXQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IGFkZGl0aXZlUGFyc2UoKTtcbiAgICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEJpbmFyeUV4cHJlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICByaWdodCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0b3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxlZnRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb21wYXJhdGl2ZVBhcnNlKCk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IodG9rZW5zOiBUb2tlbml6ZXJbJ3JldHVybnMnXSkge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcblxuICAgICAgICBjb25zdCBwcm9ncmFtID0gbmV3IFByb2dyYW0oKTtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlKCF0aGlzLmlzRmlsZUVuZCgpKSB7XG4gICAgICAgICAgICBwcm9ncmFtLmJvZHkucHVzaCh0aGlzLnBhcnNlKCkpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJldHVybnMgPSBwcm9ncmFtO1xuICAgIH1cbn0iXX0=