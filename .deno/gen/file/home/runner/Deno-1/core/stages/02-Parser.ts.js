import { additiveOperators, allOperators, comparativeOperators, multiplicitateOperators, TokenType } from "@constants";
import { Statement } from "@structures";
import { BinaryExpression, BooleanLiteral, Identifier, NumberLiteral, StringLiteral } from '@expressions';
import InterpreterError from "@errors";
export class Program extends Statement {
    kind = 'Program';
    body = [];
}
export class Parser {
    tokens = [];
    returns;
    at() {
        return this.tokens[0];
    }
    eat() {
        return this.tokens.shift();
    }
    isFileEnd() {
        return this.tokens[0].type === TokenType.EOF;
    }
    parse() {
        let primaryParse = () => {
            const tk = this.at().type;
            switch (tk) {
                case TokenType.Identifier: {
                    return new Identifier({
                        symbol: this.eat().value
                    });
                }
                case TokenType.Number: {
                    return new NumberLiteral({
                        value: parseFloat(this.eat().value)
                    });
                }
                case TokenType.String: {
                    return new StringLiteral({
                        value: this.eat().value
                    });
                }
                case TokenType.Boolean: {
                    return new BooleanLiteral({
                        value: this.eat().value === 'true' ? true : false
                    });
                }
                case TokenType.BinaryOperator: {
                    const binaryOp = this.eat();
                    if (!allOperators.includes(binaryOp.value)) {
                        throw new InterpreterError('UnexpectedCharacterError', binaryOp.value);
                    }
                    const nextToken = this.eat();
                    const isAdditiveOperation = additiveOperators.includes(binaryOp.value);
                    if (isAdditiveOperation && nextToken.type === TokenType.Number) {
                        return new NumberLiteral({
                            value: parseFloat(`${binaryOp.value}${nextToken.value}`)
                        });
                    }
                    else
                        throw new InterpreterError('SintaxError', 'number');
                }
                case TokenType.Paren: {
                    this.eat();
                    const value = this.parse();
                    this.eat();
                    return value;
                }
                default: throw new InterpreterError('SintaxError');
            }
        };
        let multiplicitaveParse = () => {
            let left = primaryParse();
            while (multiplicitateOperators.includes(this.at().value)) {
                const operator = this.eat().value;
                const right = primaryParse();
                left = new BinaryExpression({
                    left,
                    right,
                    operator,
                });
            }
            return left;
        };
        let additiveParse = () => {
            let left = multiplicitaveParse();
            while (additiveOperators.includes(this.at().value)) {
                const operator = this.eat().value;
                const right = multiplicitaveParse();
                left = new BinaryExpression({
                    left,
                    right,
                    operator,
                });
            }
            return left;
        };
        let comparativeParse = () => {
            let left = additiveParse();
            while (comparativeOperators.includes(this.at().value)) {
                const operator = this.eat().value;
                const right = additiveParse();
                left = new BinaryExpression({
                    left,
                    right,
                    operator
                });
            }
            return left;
        };
        return comparativeParse();
    }
    constructor(tokens) {
        this.tokens = tokens;
        const program = new Program();
        while (!this.isFileEnd()) {
            program.body.push(this.parse());
        }
        this.returns = program;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMDItUGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZmlsZTovLy9ob21lL3J1bm5lci9EZW5vLTEvY29yZS9zdGFnZXMvMDItUGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxZQUFZLEVBQUUsb0JBQW9CLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3ZILE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxhQUFhLENBQUM7QUFDeEMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUMxRyxPQUFPLGdCQUFnQixNQUFNLFNBQVMsQ0FBQztBQUd2QyxNQUFNLE9BQU8sT0FBUSxTQUFRLFNBQVM7SUFDbEMsSUFBSSxHQUFHLFNBQWtCLENBQUM7SUFDMUIsSUFBSSxHQUFnQixFQUFFLENBQUM7Q0FDMUI7QUFFRCxNQUFNLE9BQU8sTUFBTTtJQUNQLE1BQU0sR0FBWSxFQUFFLENBQUM7SUFDdEIsT0FBTyxDQUFVO0lBRWhCLEVBQUU7UUFDTixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFVLENBQUM7SUFDbkMsQ0FBQztJQUNPLEdBQUc7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFXLENBQUM7SUFDeEMsQ0FBQztJQUNPLFNBQVM7UUFDYixPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxHQUFHLENBQUM7SUFDakQsQ0FBQztJQUNPLEtBQUs7UUFDVCxJQUFJLFlBQVksR0FBRyxHQUFHLEVBQUU7WUFDcEIsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQztZQUUxQixRQUFRLEVBQUUsRUFBRTtnQkFDUixLQUFLLFNBQVMsQ0FB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LENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUE7U0FDbEM7UUFFRCxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztJQUMzQixDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhZGRpdGl2ZU9wZXJhdG9ycywgYWxsT3BlcmF0b3JzLCBjb21wYXJhdGl2ZU9wZXJhdG9ycywgbXVsdGlwbGljaXRhdGVPcGVyYXRvcnMsIFRva2VuVHlwZSB9IGZyb20gXCJAY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBTdGF0ZW1lbnQgfSBmcm9tIFwiQHN0cnVjdHVyZXNcIjtcbmltcG9ydCB7IEJpbmFyeUV4cHJlc3Npb24sIEJvb2xlYW5MaXRlcmFsLCBJZGVudGlmaWVyLCBOdW1iZXJMaXRlcmFsLCBTdHJpbmdMaXRlcmFsIH0gZnJvbSAnQGV4cHJlc3Npb25zJztcbmltcG9ydCBJbnRlcnByZXRlckVycm9yIGZyb20gXCJAZXJyb3JzXCI7XG5pbXBvcnQgeyBUb2tlbiwgVG9rZW5pemVyIH0gZnJvbSBcIi4vMDEtVG9rZW5pemVyLnRzXCI7XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmFtIGV4dGVuZHMgU3RhdGVtZW50IHtcbiAgICBraW5kID0gJ1Byb2dyYW0nIGFzIGNvbnN0O1xuICAgIGJvZHk6IFN0YXRlbWVudFtdID0gW107XG59XG5cbmV4cG9ydCBjbGFzcyBQYXJzZXIge1xuICAgIHByaXZhdGUgdG9rZW5zOiBUb2tlbltdID0gW107XG4gICAgcHVibGljIHJldHVybnM6IFByb2dyYW07XG5cbiAgICBwcml2YXRlIGF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnNbMF0gYXMgVG9rZW47XG4gICAgfVxuICAgIHByaXZhdGUgZWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMuc2hpZnQoKSBhcyBUb2tlbjtcbiAgICB9XG4gICAgcHJpdmF0ZSBpc0ZpbGVFbmQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2Vuc1swXS50eXBlID09PSBUb2tlblR5cGUuRU9GO1xuICAgIH1cbiAgICBwcml2YXRlIHBhcnNlKCk6IFN0YXRlbWVudCB7XG4gICAgICAgIGxldCBwcmltYXJ5UGFyc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ayA9IHRoaXMuYXQoKS50eXBlO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHRrKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuSWRlbnRpZmllcjoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IElkZW50aWZpZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiB0aGlzLmVhdCgpLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5OdW1iZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJMaXRlcmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBwYXJzZUZsb2F0KHRoaXMuZWF0KCkudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5TdHJpbmc6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdMaXRlcmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLmVhdCgpLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgVG9rZW5UeXBlLkJvb2xlYW46IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCb29sZWFuTGl0ZXJhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5lYXQoKS52YWx1ZSA9PT0gJ3RydWUnID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFRva2VuVHlwZS5CaW5hcnlPcGVyYXRvcjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5hcnlPcCA9IHRoaXMuZWF0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIWFsbE9wZXJhdG9ycy5pbmNsdWRlcyhiaW5hcnlPcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnRlcnByZXRlckVycm9yKCdVbmV4cGVjdGVkQ2hhcmFjdGVyRXJyb3InLCBiaW5hcnlPcC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLmVhdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzQWRkaXRpdmVPcGVyYXRpb24gPSBhZGRpdGl2ZU9wZXJhdG9ycy5pbmNsdWRlcyhiaW5hcnlPcC52YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoaXNBZGRpdGl2ZU9wZXJhdGlvbiAmJiBuZXh0VG9rZW4udHlwZSA9PT0gVG9rZW5UeXBlLk51bWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJMaXRlcmFsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChgJHtiaW5hcnlPcC52YWx1ZX0ke25leHRUb2tlbi52YWx1ZX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgbmV3IEludGVycHJldGVyRXJyb3IoJ1NpbnRheEVycm9yJywgJ251bWJlcicpOyBcbiAgICAgICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICAgICAgY2FzZSBUb2tlblR5cGUuUGFyZW46IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYXQoKTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMucGFyc2UoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhdCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgSW50ZXJwcmV0ZXJFcnJvcignU2ludGF4RXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbXVsdGlwbGljaXRhdmVQYXJzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBsZWZ0ID0gcHJpbWFyeVBhcnNlKClcblxuICAgICAgICAgICAgd2hpbGUobXVsdGlwbGljaXRhdGVPcGVyYXRvcnMuaW5jbHVkZXModGhpcy5hdCgpLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5lYXQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodCA9IHByaW1hcnlQYXJzZSgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgQmluYXJ5RXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFkZGl0aXZlUGFyc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IG11bHRpcGxpY2l0YXZlUGFyc2UoKVxuXG4gICAgICAgICAgICB3aGlsZShhZGRpdGl2ZU9wZXJhdG9ycy5pbmNsdWRlcyh0aGlzLmF0KCkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLmVhdCgpLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbXVsdGlwbGljaXRhdmVQYXJzZSgpO1xuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgQmluYXJ5RXhwcmVzc2lvbih7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBvcGVyYXRvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbXBhcmF0aXZlUGFyc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbGVmdCA9IGFkZGl0aXZlUGFyc2UoKVxuICAgICAgICBcbiAgICAgICAgICAgIHdoaWxlKGNvbXBhcmF0aXZlT3BlcmF0b3JzLmluY2x1ZGVzKHRoaXMuYXQoKS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRvciA9IHRoaXMuZWF0KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBhZGRpdGl2ZVBhcnNlKCk7XG4gICAgICAgICAgICAgICAgbGVmdCA9IG5ldyBCaW5hcnlFeHByZXNzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBsZWZ0XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29tcGFyYXRpdmVQYXJzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHRva2VuczogVG9rZW5pemVyWydyZXR1cm5zJ10pIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG5cbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKCk7XG4gICAgICAgIFxuICAgICAgICB3aGlsZSghdGhpcy5pc0ZpbGVFbmQoKSkge1xuICAgICAgICAgICAgcHJvZ3JhbS5ib2R5LnB1c2godGhpcy5wYXJzZSgpKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXR1cm5zID0gcHJvZ3JhbTtcbiAgICB9XG59Il19